#! /bin/sh -e
if [ $# -ne 1 ]; then 
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1  
fi
case "$1" in 
    -patch) patch -f --no-backup-if-mismatch -p1 < $0;;
    -unpatch) patch -f --no-backup-if-mismatch -R -p1 < $0;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1;;
esac

exit 0

@DPATCH@
diff -Nur nullmailer-1.04.orig/doc/nullmailer-send.8 nullmailer-1.04/doc/nullmailer-send.8
--- nullmailer-1.04.orig/doc/nullmailer-send.8	2007-10-09 18:35:44.000000000 +0200
+++ nullmailer-1.04/doc/nullmailer-send.8	2008-01-06 14:58:18.000000000 +0100
@@ -3,6 +3,7 @@
 nullmailer-send \- Send queued messages
 .SH SYNOPSIS
 .B nullmailer-send
+.RB [ \-\-daemon ]\ [ \-\-syslog ]
 .SH DESCRIPTION
 This program is responsible for coordinating the transmission of
 messages that have been queued by
@@ -37,6 +38,15 @@
 sleeps for a number of seconds specified by
 .B pausetime
 before retrying sending the contents of the queue.
+.SH OPTIONS
+.TP
+.BR \-d ,\  \-\-daemon
+Fork into the background, implies --syslog.
+.TP
+.BR \-s ,\  \-\-syslog
+Use syslog for error and log messages.
+With --daemon, syslog will be used exclusively, without --daemon,
+syslog will be used additionally.
 .SH CONTROL FILES
 All the control files are reread each time the queue is run.
 .TP
diff -Nur nullmailer-1.04.orig/protocols/protocol.cc nullmailer-1.04/protocols/protocol.cc
--- nullmailer-1.04.orig/protocols/protocol.cc	2007-10-10 01:33:02.000000000 +0200
+++ nullmailer-1.04/protocols/protocol.cc	2008-01-06 15:00:10.000000000 +0100
@@ -22,11 +22,15 @@
 #include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <sys/syslog.h>
 #include "connect.h"
 #include "errcodes.h"
 #include "protocol.h"
 #include "cli++.h"
 
+static int use_syslog = 0;
+static int daemonize  = 0;
+
 const char* user = 0;
 const char* pass = 0;
 int auth_method = AUTH_PLAIN;
@@ -41,6 +45,8 @@
     "Set the user name for authentication", 0 },
   { 0, "pass", cli_option::string, 0, &pass,
     "Set the password for authentication", 0 },
+  { 'd', "daemon", cli_option::flag, 1, &daemonize,  "use syslog exclusively ", 0 },
+  { 's', "syslog", cli_option::flag, 1, &use_syslog, "use syslog additionally", 0 },
   { 0, "auth-login", cli_option::flag, AUTH_LOGIN, &auth_method,
     "Use AUTH LOGIN instead of AUTH PLAIN in SMTP", 0 },
   {0, 0, cli_option::flag, 0, 0, 0, 0}
@@ -48,18 +54,28 @@
 
 void protocol_fail(int e, const char* msg)
 {
-  ferr << cli_program << ": Failed: " << msg << endl;
+  if (use_syslog)
+    syslog(LOG_ERR, "%s: Failed: %s", cli_program, msg);
+  if (!daemonize)
+    ferr << cli_program << ": Failed: " << msg << endl;
   exit(e);
 }
 
 void protocol_succ(const char* msg)
 {
-  ferr << cli_program << ": Succeeded: " << msg << endl;
+  if (use_syslog)
+    syslog(LOG_ERR, "%s: Succeeded: %s", cli_program, msg);
+  if (!daemonize)
+    ferr << cli_program << ": Succeeded: " << msg << endl;
   exit(0);
 }
 
 int cli_main(int, char* argv[])
 {
+  if (daemonize)
+    use_syslog = 1;
+  if (use_syslog)
+    openlog("nullmailer", LOG_CONS | LOG_PID, LOG_MAIL);
   const char* remote = argv[0];
   fdibuf in(0, true);
   protocol_prep(&in);
diff -Nur nullmailer-1.04.orig/src/Makefile.in nullmailer-1.04/src/Makefile.in
--- nullmailer-1.04.orig/src/Makefile.in	2007-10-10 01:23:25.000000000 +0200
+++ nullmailer-1.04/src/Makefile.in	2008-01-06 15:01:31.000000000 +0100
@@ -59,7 +59,7 @@
 nullmailer_queue_DEPENDENCIES = ../lib/libnullmailer.a
 am_nullmailer_send_OBJECTS = send.$(OBJEXT)
 nullmailer_send_OBJECTS = $(am_nullmailer_send_OBJECTS)
-nullmailer_send_DEPENDENCIES = ../lib/libnullmailer.a
+nullmailer_send_DEPENDENCIES = ../lib/cli++/libcli++.a ../lib/libnullmailer.a
 am_sendmail_OBJECTS = sendmail.$(OBJEXT)
 sendmail_OBJECTS = $(am_sendmail_OBJECTS)
 sendmail_DEPENDENCIES = ../lib/cli++/libcli++.a ../lib/libnullmailer.a
@@ -175,13 +175,13 @@
 #noinst_PROGRAMS = address
 INCLUDES = -I../lib -I../lib/cli++
 mailq_SOURCES = mailq.cc
-mailq_LDADD = ../lib/libnullmailer.a
+mailq_LDADD = ../lib/cli++/libcli++.a ../lib/libnullmailer.a
 nullmailer_inject_SOURCES = inject.cc
 nullmailer_inject_LDADD = ../lib/cli++/libcli++.a ../lib/libnullmailer.a
 nullmailer_queue_SOURCES = queue.cc
 nullmailer_queue_LDADD = ../lib/libnullmailer.a
 nullmailer_send_SOURCES = send.cc
-nullmailer_send_LDADD = ../lib/libnullmailer.a
+nullmailer_send_LDADD = ../lib/cli++/libcli++.a ../lib/libnullmailer.a
 sendmail_SOURCES = sendmail.cc
 sendmail_LDADD = ../lib/cli++/libcli++.a ../lib/libnullmailer.a
 all: all-am
diff -Nur nullmailer-1.04.orig/src/send.cc nullmailer-1.04/src/send.cc
--- nullmailer-1.04.orig/src/send.cc	2007-10-09 18:33:53.000000000 +0200
+++ nullmailer-1.04/src/send.cc	2008-01-06 15:10:23.000000000 +0100
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
+#include <sys/syslog.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
@@ -40,14 +41,30 @@
 #include "list.h"
 #include "selfpipe.h"
 #include "setenv.h"
+#include "cli++/cli++.h"
 
 selfpipe selfpipe;
 
 typedef list<mystring> slist;
 
-#define fail(MSG) do { fout << MSG << endl; return false; } while(0)
-#define fail2(MSG1,MSG2) do{ fout << MSG1 << MSG2 << endl; return false; }while(0)
-#define fail_sys(MSG) do{ fout << MSG << strerror(errno) << endl; return false; }while(0)
+static int use_syslog = 0;
+static int daemonize  = 0;
+
+const char* cli_program     = "nullmailer-send";
+const char* cli_help_prefix = "nullmailer daemon\n";
+const char* cli_help_suffix = "";
+const char* cli_args_usage  = "";
+const int cli_args_min = 0;
+const int cli_args_max = 0;
+cli_option cli_options[] = {
+  { 'd', "daemon", cli_option::flag, 1, &daemonize,  "daemonize , implies --syslog", 0 },
+  { 's', "syslog", cli_option::flag, 1, &use_syslog, "use syslog", 0 },
+  { 0, 0, cli_option::flag, 0, 0, 0, 0 }
+};
+
+#define fail(MSG) do { if (use_syslog) syslog(LOG_ERR, "%s", MSG); if (!daemonize) ferr << MSG << endl; return false; } while (0)
+#define fail2(MSG1,MSG2) do { if (use_syslog) syslog(LOG_ERR, "%s %s", MSG1, MSG2); if (!daemonize) fout << MSG1 << MSG2 << endl; return false; } while (0)
+#define fail_sys(MSG) do { if (use_syslog) syslog(LOG_ERR, "%s %s", MSG, strerror(errno)); if (!daemonize) ferr << MSG << strerror(errno) << endl; return false; } while (0)
 
 struct remote
 {
@@ -154,7 +171,10 @@
 bool load_files()
 {
   reload_files = false;
-  fout << "Rescanning queue." << endl;
+  if (use_syslog)
+    syslog(LOG_INFO, "Rescanning queue.");
+  if (!daemonize)
+    fout << "Rescanning queue." << endl;
   DIR* dir = opendir(".");
   if(!dir)
     fail_sys("Cannot open queue directory: ");
@@ -172,12 +192,19 @@
 
 void exec_protocol(int fd, remote& remote)
 {
-  if(close(0) == -1 || dup2(fd, 0) == -1 || close(fd) == -1)
+  if (!daemonize && close(STDIN_FILENO) < 0)
     return;
+  if (fd != STDIN_FILENO)
+    if (dup2(fd, STDIN_FILENO) < 0 || close(fd) < 0)
+      return;
   mystring program = PROTOCOL_DIR + remote.proto;
-  const char* args[3+remote.options.count()];
+  const char* args[5+remote.options.count()];
   unsigned i = 0;
   args[i++] = program.c_str();
+  if (daemonize)
+    args[i++] = "-d";
+  if (use_syslog)
+    args[i++] = "-s";
   for(slist::const_iter opt(remote.options); opt; opt++)
     args[i++] = strdup((*opt).c_str());
   args[i++] = remote.host.c_str();
@@ -213,7 +240,10 @@
       if(status)
 	fail2("Sending failed: ", errorstr[status]);
       else {
-	fout << "Sent file." << endl;
+        if (use_syslog)
+          syslog(LOG_INFO, "Sent file.");
+        if (!daemonize)
+             fout << "Sent file." << endl;
 	return true;
       }
     }
@@ -226,10 +256,20 @@
 {
   int fd = open(filename.c_str(), O_RDONLY);
   if(fd == -1) {
-    fout << "Can't open file '" << filename << "'" << endl;
+    if (use_syslog)
+      syslog(LOG_ERR, "Can't open file '%s'", filename.c_str());
+    if (!daemonize)
+      fout << "Can't open file '" << filename << "'" << endl;
     return false;
   }
-  fout << "Starting delivery: protocol: " << remote.proto
+  if (use_syslog)
+    syslog(LOG_INFO, "Starting delivery: protocol: %s host: %s file: %s",
+      remote.proto.c_str(), remote.host.c_str(), filename.c_str());
+  if (!daemonize)
+  if (use_syslog)
+    syslog(LOG_INFO, "Starting delivery, %d message(s) in queue.", files.count());
+  if (!daemonize)
+    fout << "Starting delivery: protocol: " << remote.proto
        << " host: " << remote.host
        << " file: " << filename << endl;
   pid_t pid = fork();
@@ -268,7 +308,10 @@
 	file++;
     }
   }
-  fout << "Delivery complete, "
+  if (use_syslog)
+    syslog(LOG_INFO, "Delivery complete, %d message(s) remain.", files.count());
+  if (!daemonize)
+    fout << "Delivery complete, "
        << itoa(files.count()) << " message(s) remain." << endl;
   return true;
 }
@@ -313,7 +356,10 @@
   int s = select(trigger+1, &readfds, 0, 0,
 		 (files.count() == 0) ? 0 : &timeout);
   if(s == 1) {
-    fout << "Trigger pulled." << endl;
+    if (use_syslog)
+      syslog(LOG_INFO, "Trigger pulled.");
+    if (!daemonize)
+      fout << "Trigger pulled." << endl;
     read_trigger();
     reload_files = true;
   }
@@ -326,8 +372,14 @@
   return true;
 }
 
-int main(int, char*[])
+int cli_main(int, char*[])
 {
+  pid_t pid;
+
+  if (daemonize)
+    use_syslog = 1;
+  if (use_syslog)
+    openlog("nullmailer", LOG_CONS | LOG_PID, LOG_MAIL);
   read_hostnames();
 
   if(!selfpipe) {
@@ -336,13 +388,34 @@
   }
   selfpipe.catchsig(SIGCHLD);
   
-  if(!open_trigger())
+  if(!open_trigger()) {
+    if (use_syslog)
+      syslog(LOG_CRIT, "Could not open trigger.");
+    if (!daemonize)
+      ferr << "Could not open trigger." << endl;
     return 1;
+  }
   if(chdir(QUEUE_MSG_DIR) == -1) {
     fout << "Could not chdir to queue message directory." << endl;
+    if (use_syslog)
+      syslog(LOG_CRIT, "Could not chdir to queue message directory.");
+    if (!daemonize)
+      ferr << "Could not chdir to queue message directory." << endl;
     return 1;
   }
-  
+
+  if (daemonize) {
+    if ((pid = fork()) < 0) {
+      syslog(LOG_CRIT, "Could not fork.");
+      return 1;
+    }
+    if (pid)
+      return 0;
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
+  }
+
   signal(SIGALRM, catch_alrm);
   signal(SIGHUP, SIG_IGN);
   load_config();
